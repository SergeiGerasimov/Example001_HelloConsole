// Первая группа методов
// Методы первой группы очень простые и выглядят следующим образом. Допустим:
// void Metod1()
// {
// Console.WriteLine("Автор …");
// }
// Обратите внимание, у нас ключевое слово void. В скобках нет никаких аргументов. И есть
// тело метода, которое что-то может, например, показывать на экран. То есть в конце
// каждой созданной программы вы, быть может, хотите указывать своё авторство.
// 3
// Следующий пункт, который может быть интересен или нужен, это вариант, как
// вызываются подобного рода методы. А вызываются они очень просто, вы должны будете
// указать:
// Metod1() — где Metod1, является идентификатором метода.
// Пожалуйста, будьте внимательны, потому что в некоторых случаях начинающие вызывают
// методы без использования скобок. В этом случае при выполнении программы будет
// ошибка. Проверим это в терминале с помощью команды dotnet run и убедимся в том, что
// действительно будет ошибка. При этом если мы напишем всё правильно, то на экране мы
// увидим:
// Автор …
//Metod1() — добавление // превратит команду в комментарий, мало влияющий на код.

// Вторая группа методов
// Следующая группа методов это пусть так и называется Metod2.
// void Metod2(string msg, int count) //— где void ключевое слово, дальше идентификатор, в скобках
// // указаны какие-то аргументы.
// {
//     int i = 0;
//     while (i < count)
//     {Console.WriteLine(msg); //— оператор, в скобках указан принятый аргумент.
//     i++;
//     }
// }
// Metod2(count: 4, msg: "новый текст"); //— где Metod2 является идентификатором, а в скобках
// // указан текст, выводимый в консоли.
// // Это методы, которые ничего не возвращают, но в то же время могут принимать какие-то
// // аргументы. Я ещё сразу же запущу и продемонстрирую тот факт, что вызов Metod2 будет
// // отображать в консоли именно тот текст, который мы указали.

// Именованные аргументы
// Отмечу, что ещё есть так называемые именованные аргументы, когда у нас явно может быть
// указано какому аргументу, какое значение мы хотим указать. Это часто бывает нужно, если
// методы принимают какое-то количество аргументов, отличное от 1. Продемонстрирую это.
// void Metod21(string msg, int count)
// {
// int i = 0;
// while (i < count)
// {
// Console.WriteLine(msg); - где переменная count отображает на экране
// определённое количество сообщений msg.
// count++; - а надо i++;
// }
// }
// Metod21(“Текст”, 4); - метод вызывает Текст, после запятой указано количество
// вызовов, в нашем случае 4.
// Здесь будет использоваться значение переменной count, чтобы показывать на экране
// определённое количество сообщений, которые будут передаваться непосредственно в наш
// метод.
// Увеличение счётчика на 1 называют инкрементом, а уменьшение на 1 очень часто называют
// декрементом. Так что можете несколько слов программистских записать в словарик.
// За комментируем вызов //Method2. И отправим на выполнение Method21. Ожидаем увидеть
// слово Текст 4 раза, но видим больше. Почему? Потому что я увеличиваю count, а нужно
// увеличивать i. Напоминаю, что если вдруг случилось зацикливание программы, то это можно
// исправить с помощью Ctrl+c. Причём неважно будет у вас Mac или Windows. Перезапустим и
// убедимся в том, что всё будет хорошо. И теперь наблюдаем 4 раза слово Текст.
// Теперь идея в том, что мы можем в том числе явно указывать к какому аргументу, какое
// значение мы хотим присвоить, через такую конструкцию.
// Было: Metod21(“Текст”, 4);
// Стало: Metod21(msg: “Текст”, count: 4);
// Явно указывая наименование аргумента, не обязательно писать их по порядку.
// Metod21(count: 4, msg: “Текст”);
// Это тоже особенность, то есть можно, например, написать count: 4, дальше написать msg:
// Новый текст. Теперь если запускать в таком формате, то мы увидим Новый текст на экране
// точно же 4 раза. Ура, всё работает


// Третья группа методов
// Эти методы, которые что-то возвращают, но ничего не принимают. Если метод что-то
// возвращает, мы в обязательном порядке должны указать тип данных, значение которого
// ожидаем. Для нас это будет Metod3.
// int Metod3() //- не принимает никакие аргументы
// {
// return DataTime.Now.Year; //- обязательное использование оператора return,
// }
// int year = Metod3(); //- вызываем метод, в левой части используем идентификатор
// //переменной (year) и через оператор присваивания (=) кладём нужное значение
// Console.WriteLine(year);
// // В дальнейшем используем переменную year, и то значение, которое нам вернул метод. То есть
// // return DataTime.Now.Year провёл какую-то работу и в переменную year будет положен
// // результат работы метода, дальше мы можем его использовать. Перезапустим консоль. В
// // результате ожидаем в консоли увидеть 2021. Действительно, всё хорошо.

// Четвёртая группа методов
// Самая важная группа методов, это методы, которые что-то принимают и что-то возвращают.
// string Metod4(int count, string text)
// {
// string result = String.Empty;
// for(int i = 0; i<count; i++) // цикл for
// {
// result = result + text;
// }
// return result;
// }
// string res = Metod4(10, "asdf ");
// Console.WriteLine(res);
// Возвращать будем строку string, по традиции называем метод Metod4. Передавать будем int
// count и условный тип char, новый тип данных для вас. Соответственно, что мы здесь делаем?
// Мы будем string компоновать друг за другом count раз.
// Сделаем это. Для начала возьмем цикл, дальше нам потребуется переменная куда мы будем
// класть результат, конечный string result. Изначально можно и нужно в неё положит какое-то
// значение. Этим значением является пустая строка, чтобы не только вы понимали написанный
// код, более правильно, будет написать string.Empty. То есть таким образом мы можем просто
// прочитать, result у нас изначально будет пустой строкой. После этого используем конструкцию
// while. В которой пока i < count. Обязательно не забываем увеличивать счётчик и класть в
// result = result + text (это строчка, которую мы указали). Здесь, кстати в общем случае можно,
// например, правой кнопкой сделать rename и написать условный текст, тогда будет не только
// символ, но и текст. Таким образом, у нас везде текст меняется, и соответственно,
// наименование аргумента будет изменяно.
// После того, как данный метод отработает, используем классический и известный оператор
// return, в котором указываем результат или переменную значение, которой ожидаем получить
// из метода. Чтобы вызвать этот метод мы должны будем, создать нужную нам переменную,
// дальше по порядочку указать, например, значение 10 и текст, который мы будем склеивать 10
// раз, пусть это будет условный asdf текст. После этого можем показать на экране результат,
// который этот метод будет возвращать. Очистим консоль и запустим метод. Для проверки
// заменим условный текст на букву z. Ожидаем увидеть эту последовательность 10 раз.
// string res = Metod4(10, “z”);
// Console.WriteLine(res);
// И действительно, она есть. Мы получаем результирующую строку, состоящую из 10 букв Z.


// Цикл в цикле

for (int i = 2; i <= 10; i++)
{
for (int j = 2; j <= 10; j++)
{
Console.WriteLine($"{i} * {j} = {i * j}"); // интераполяция строк
}
Console.WriteLine();
}
